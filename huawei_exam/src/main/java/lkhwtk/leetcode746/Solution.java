package lkhwtk.leetcode746;

/**
 * 746. 使用最小花费爬楼梯
 * 二轮复习整理：dp[i]代表在i层楼梯之前，耗费的体力，不算i，一共n个元素，最终一定要统计到dp[n+1]才是最终走完顶楼的疲劳值统计
 * 注意：本题题目有一个不好理解的点，数组中最后一个元素位置不代表楼梯的顶楼，走完最后一个元素才是顶楼，也就是动态规划得多规划一步，dp数组长度为n+1
 * 每次走一步或两步，就是往后走一步或者走两步，走两步相当于跳过了一个台阶，下次从当前台阶体力消耗值开始
 * 这个例题：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]，从0或者1开始，这道题直觉是从0开始，
 *                   0    1  2  3  4   5   6  7   8   9
 * 从0开始，走两步到2，总花费1，从2跳过3到4，总花费1+1=2，然后4走两步到6，总花费1+1+1=3,6走一步到7，总花
 * 费1+1+1+1=4，7走两步到9，总花费4+1=5,9还要再走一层到顶楼，花费5+1=6
 */
public class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int n = cost.length;
        //因为涉及到最后一个顶楼，这个体力耗费值也要统计，初始化动态规划数组长度为n+1
        int[] dp = new int[n + 1];
        //0和1累计花费都是0，可以从0和1开始
        dp[0] = dp[1] = 0;
        for (int i = 2; i <= n; i++) {
            //动态规划的核心，dp[i]可以从dp[i-1]和dp[i-2]两个状态规划过来
            dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
        }
        return dp[n];
    }
}
