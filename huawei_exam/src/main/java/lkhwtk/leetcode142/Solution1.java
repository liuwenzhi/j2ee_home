package lkhwtk.leetcode142;

/**
 * 参考题解：环形链表 II（双指针法，清晰图解）
 * 仔细分析题解说的有些不清楚的地方，顺着题解的顺序，一点一点整理如下：
 * 1、没有环的情况慢指针走到最后，发现节点为null或者next为null了，这个非常正确，因为是每次走两步，单链表的节点数可能是奇数，也可能是偶数，所以
 * if(fast == null || fast.next == null)条件不满足的情况下，返回null，这个说的没问题；
 * 2、快指针和慢指针肯定会相遇，相遇点肯定在环里边，如果单链表有环，那么快指针和慢指针都会进入环中不断循环。题解中说的每走一轮，实际是快指针走两步，慢指针走一步，
 * 不是全程都走完，快指针每次走两步，慢指针每次走一步，不管有没有进入环，快指针和慢指针每次的间距都会加1，进入环之后，每次增加1这个间距让快指针和慢指针在环中肯定会相遇；
 * 3、指针走的步数，步数是走过的节点数-1，可以自己画一个带有环的单链表，第一次相遇的时候，快指针走的步数正好是慢指针的两倍。
 * 4、在第一轮相遇之后，根据题解中的公式推导，慢指针再走非环长度的步数就能走到入口，因为目前没有统计出单链表长度，环的长度和非环的长度，所以可以再借助一个指针，
 * 让这个指针从head节点开始走到和慢指针相遇，即正好非环长度，这个时候，相遇的这个点就是环的入口。再创建一个指针没有必要，直接用fast即可，构建第二次相遇的时候，fast
 * 指针已经不是快指针了，就是每次走一步。
 * 题解中推导是基于步数来推的公式，步数等于走过的节点数（算上开始和结束）-1，这个可以自己画画就看出来了。
 */
public class Solution1 {
    public ListNode detectCycle(ListNode head) {
        ListNode fast = head, slow = head;
        while (true) {
            //没有环，直接返回null，快指针走到了一个链表的结尾
            if (fast == null || fast.next == null){
                return null;
            }
            fast = fast.next.next;
            slow = slow.next;
            if (fast == slow) break;
        }
        //第一轮相遇之后，构建第二轮相遇，第二轮的时候fast放到head位置，快指针和慢指针都是每次走一步，相遇的点就是环的入口
        fast = head;
        while (slow != fast) {
            slow = slow.next;
            fast = fast.next;
        }
        return fast;
    }
}
