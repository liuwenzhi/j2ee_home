package lkhwtk.leetcode1105;

import java.util.Arrays;

/**
 * 1105. 填充书架
 * 参考题解：动态规划 Python3
 * 核心思路：dp[i] 表示放置前 i 本书所需要的书架最小高度，按照入参顺序，一本一本的拿书，维护一个书架最后一层的宽度和最后一层最大高度，
 * 每次来一本书，放到最后一层，然后依次拿这本书前边的书，看看能不能放到这本书同层（需要宽度允许），能放下的情况下，能否让最大高度变小，
 * 能变小就放到最后一层，和当前书同层，然后循环这个过程一直到最后一本书。因为题目中要求：摆放书的顺序与你整理好的顺序相同，所以只能从
 * 当前书往前一本一本拿来试，不能跳着拿。
 */
public class Solution {
    public int minHeightShelves(int[][] books, int shelf_width) {
        //没有书，最小高度也就是没有高度
        if(books.length==0) {
            return 0;
        }
        int len=books.length;
        //用 dp[i] 表示放置前 i 本书所需要的书架最小高度
        int dp[]=new int [len+1];
        //初始化动态规划数组，按照提示信息，每本书最大高度是1000，最多1000本书，先把数组中每一个元素初始化为高度最大值
        Arrays.fill(dp,1000*1000);
        //初始化完整个数组之后，一个元素一个元素的处理，dp[0] = 0
        dp[0]=0;
        for(int i = 0; i<books.length; i++){
            int j=i-1;
            //w是最底层的宽度，最底层实际就是当前已有书架设计下边再加一层，初始化为当前书的宽度（最底层就是题解中说的最后一层）
            int w=books[i][0];
            //maxHigh是最底层的高度，最底层实际就是当前已有书架设计下边再加一层，初始化最底层最大高度为当前书的高度，每一次先把书单独放到最底层（最底层就是题解中说的最后一层）
            int maxHigh=books[i][1];
            //在当前书的前边存在书籍同时当前书籍的宽度和之前书籍的宽度之和小于书架宽度的情况下开始内存循环
            while(j>=0&&w+books[j][0]<=shelf_width){
                //如果books[j]的高度比当前最底层的书的高度大，将最底层的高度设置为books[j]的高度，实际是将books[j]调整到最底层，和当前书同一层
                if(maxHigh<books[j][1]) {
                    maxHigh=books[j][1];
                }
                //在经过if中可能的调整之后，调整整个最大高度，注意：j是从i-1开始，每一次涉及到调整，则dp中两个下标值至少相差2，
                //这个可以从题解中的动态图进行观察，不调整的时候是dp[i+1]和dp[i]的关系，一旦涉及到调整，则是dp[i+1]和dp[i]之前的dp[i-1]等元素的关系
                dp[i+1]=Math.min(dp[i+1],dp[j]+maxHigh);
                //调整之后重新统计最底层（最底层就是题解中说的最后一层）宽度，不能跳着拿，必须一本一本拿，所以每次宽度都要统计上，如果宽度达到书架最大宽度，则直接跳出while循环
                w+=books[j][0];
                j--;
            }
            //补充一个优化，dp[i]的值直接累加当前书的高度值，和dp[i+1]做一个比对，这里是对while循环的一个补充，while循环中没有
            dp[i+1]=Math.min(dp[i]+books[i][1],dp[i+1]);
        }
        return dp[dp.length-1];
    }
}
