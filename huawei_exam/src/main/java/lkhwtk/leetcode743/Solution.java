package lkhwtk.leetcode743;

import java.util.Arrays;

/**
 * 743. 网络延迟时间
 * 参考题解：【GTAlgorithm】图解算法，吃透一个Dijkstra就够了！C++/Java/Python
 * 该题解对迪加斯它算法进行了详细解读，说的不错。个人理解：
 * 1、找到原点（即入口点）能直接到达的节点（直接到达，中间不经过其他节点），将这些路径权值信息维护到邻接矩阵中；
 * 2、在邻接矩阵中找到距离原点最近的节点node，通过node节点能直接到达的目的节点更新邻接矩阵中原点到这些目的节点的距离，如果原点通过节点node让到这些节点的距离更小，则更新；
 * 3、重复第2步，直到所有节点全都遍历完；题解中给出的例子，每次定位x节点是根据每次循环之后，哪个节点距离原点更近
 * 备注：无向图的邻接矩阵都是基于主对角线对称的，有向图不一定。
 * 参考题解：官方。理解好迪加斯它算法之后，看看官方代码。上边题解实际就是抄了官方题解代码。
 * 本题中的题解斯它算法，类似于图的最小生成树中Prim算法，图的最小生成树算法还有一个克鲁斯卡尔算法，具体见1631题和721题实现。
 */
public class Solution {
    /**
     * 入参n是节点个数，k是起始节点
     */
    public int networkDelayTime(int[][] times, int n, int k) {
        /**最大路径值，最多100个节点，最长路径100，最大路净值肯定不会超过9901，9900即一个单链表，从第一个节点到最后一个节点，每条边权值都是100*/
        final int INF = 9901;
        //创建邻接矩阵，存储有向边权值信息，对应n个节点，创建n*n大小的邻接矩阵
        int[][] g = new int[n][n];
        //注意这种二维数组的赋值方式，遍历二维数组，然后给每一行的一维数组赋值INF
        for (int i = 0; i < n; ++i) {
            Arrays.fill(g[i], INF);
        }
        //给邻接矩阵赋值
        for (int[] t : times) {
            //题目中节点编号从1开始，存储到矩阵对应从0开始，注意第一参考题解中给出的例子节点是从0开始的
            int x = t[0] - 1, y = t[1] - 1;
            g[x][y] = t[2];
        }
        //从源点到某点的距离数组，加一个这个数组比直接修改邻接矩阵最后再找最大值方便一点
        int[] dist = new int[n];
        Arrays.fill(dist, INF);
        //由于从 k 开始，所以该点距离设为 0，也即源点
        dist[k - 1] = 0;
        //节点是否被更新数组
        boolean[] used = new boolean[n];

        /*
        * for循环是整个迪迦斯它算法的核心，最外层for循环遍历dist数组，实际就是n个节点循环N次，然后在内层第一层for循环中，
        * 实际是每次固定一个顶点，迪迦斯它算法就是每次找到一个距离源点最近的点，维护进来，然后再去维护路径，第一个for循环的核心是比较dist数组中的元素，
        * 注意：首次进入这个循环的时候，只有dist[k-1]这个位置的值被初始化了，所以第一次找到的是源点赋值给了x，然后再去找和源点最近的那些点，更新距离，
        * 在外层循环i=0这一轮遍历之后，dist[y]数组中有部分元素被更新，然后继续找距离源点最近的点，还是去比较dist数组，使用used数组中未标记过的元素，
        * 注意：这里的思路可能直觉感觉和图解中的内容不太一样，实际完全一致，因为引入新的节点之后，去更新各个点到源点的距离，实际就是对应了图解中的变化，源点
        * 到其它点的最短路径因为引入的节点而变小。
        */
        for (int i = 0; i < n; ++i) {
            // 在还未确定最短路的点中，寻找距离原点最短路径的节点，下边设置x=-1，然后在if中配的条件非常巧妙
            //保证只要有没用到的点，就给x赋值，然后还能找到距离原点最小的那个点
            int x = -1;
            for (int y = 0; y < n; ++y) {
                if (!used[y] && (x == -1 || dist[y] < dist[x])) {
                    x = y;
                }
            }
            //更新该点已经找到了最小距离，用该点更新所有其他点的距离
            used[x] = true;
            for (int y = 0; y < n; ++y) {
                //dist[x]是原点到x的距离，g[x][y]是x到y的距离，更新下最小距离数组，按照迪迦斯它算法，这里可以加一个if (!used[y])条件，但并没有省时
                //if (!used[y])
                dist[y] = Math.min(dist[y], dist[x] + g[x][y]);
            }
        }

        // 找到距离最远的点，用流这种方式高端，优雅，但是会影响效率
        //int ans = Arrays.stream(dist).max().getAsInt();
        //用这种最土的方式，能省1ms时间，直接把时间效率提到最高
        int ans = -1;
        for(int i:dist){
            ans = Math.max(ans,i);
        }
        return ans == INF ? -1 : ans;
    }
}
