package lkhwtk.leetcode498;

/**
 * 498. 对角线遍历
 * 参考题解：简单易懂
 * 本题思路和螺旋矩阵有一点类似，二轮复习的时候可以一起看下
 * 核心思路：定义 i，j为矩阵中的指针，fx为遍历的方向，1为右上，-1为左下
 * 每次循环先判断是否在边界需要变向
 * 如果不在边界则按遍历的方向fx，变化i和j
 * 注：右边界和下边界先判断
 */
public class Solution {
    public int[] findDiagonalOrder(int[][] mat) {
        int m=mat.length;
        int n=mat[0].length;
        int[] ret=new int[m*n];
        //取值从(0,0)开始
        int i=0,j=0;
        //fx作为一个方向变量，1代表右上，-1代表左下
        int fx=1;
        for(int cur=0;cur<ret.length;cur++){
            ret[cur]=mat[i][j];
            //如果是右上方向，并且到了右侧边界，改为左下方向，横坐标+1（即：遍历同列下一行元素）
            if(j==n-1&&fx==1){
                fx=-1;
                i=i+1;
                continue;
            }
            //如果是左下方向，并且到了下方边界，改为右上方向，纵坐标+1（即：遍历同行下一列元素）
            if(i==m-1&&fx==-1){
                fx=1;
                j=j+1;
                continue;
            }
            //如果是右上方向，并且在上方边界，注意：在右上的处理上，是先判断到了右侧边界，然后再判断到了上方边界，主要是出于右上角的处理，到了右上角肯定往下，不能往右了
            //此时改为左下方向，纵坐标+1，即：遍历同行下一列元素，如果是右上方向，同时到了上边界和右边界，则肯定是按照右边界处理，遍历同列下一行元素
            if(i==0&&fx==1){
                fx=-1;
                j=j+1;
                continue;
            }
            //如果是左下方向，并且到了左方边界，注意：在左下的处理上，是先判断到了下方边界，然后判断到了左方边界，主要是到达左下角的处理，肯定是往右，不能往下了
            //此时改为右上方向，横坐标+1，即：遍历同列下一行元素，如果是左下方向，同时到了左边界和下边界，肯定按照下方编辑来处理，遍历同行下一列元素
            if(j==0&&fx==-1){
                fx=1;
                i=i+1;
                continue;
            }
            //如果没有达到边界，i和j根据fx的值做改变，当fx=1，右上方向上，每次i-1,j+1
            //当fx=-1，左下方向上，每次i+1,j-1，不管fx正负，直接按照下边公式计算即可
            i=i-fx;
            j=j+fx;
        }
        return ret;

    }
}
