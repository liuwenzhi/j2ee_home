package lkhwtk.leetcode1025;

/**
 * 1025. 除数博弈
 * 本题看起来很绕，实际是一个脑筋急转弯
 * 参考题解：除数博弈+python3+归纳法+动态规划，其实是一道数学题，官方有这个证明过程。
 */
public class Solution {
    public boolean divisorGame(int n) {
        //爱丽丝先手，如果n是偶数，则稳赢，只需要每次选择1，每次选择1，让n-1一直处于奇数状态，
        //因为奇数的约数只能是奇数，所以不论鲍勃怎么选，到下一轮剩下来的都是偶数，爱丽丝只要一直选1
        //就能将结果拖到n=2-1这里，留下一个1，鲍勃输掉。有一个点，比如初始是57，爱丽丝拿19，剩余36
        //然后鲍勃拿1，剩余35，爱丽丝拿5，剩余30，鲍勃拿1，剩余29，这个时候爱丽丝只能在拿1，剩余28
        //不管前边怎么选，最后都是到了2和1这里，只要是两方都足够聪明，先手是偶数就一定能赢。在这个
        //模拟中，如果爱丽丝拿19，剩余36的时候，如果鲍勃拿2，剩余34，这个时候，爱丽丝就可以拿1，剩余33，
        //这样可以把鲍勃搞掉，比如此时鲍勃拿11，剩余22，爱丽丝拿1，剩余21，鲍勃拿7，剩余14，爱丽丝拿1
        //剩余13，鲍勃拿1，剩余12，爱丽拿1，剩余11...一直到最后爱丽丝拿2，剩余1，鲍勃无数字可用，这个
        //就是不够聪明的一个反例，总之只要是偶数开始，爱丽丝一直拿奇数，把下一个奇数抛给鲍勃，再下一个
        //偶数留给自己，就会稳赢
        return n%2==0;
    }
}
